# Debug Adapter ↔ Compiler Integration Guide

**Document Type**: Integration Guide  
**Version**: 1.0  
**Last Updated**: December 22, 2025  
**Status**: Reference Documentation

---

## Table of Contents

1. [Overview](#overview)
2. [DWARF Debug Information](#dwarf-debug-information)
3. [Source Line Mapping](#source-line-mapping)
4. [Variable Debug Info](#variable-debug-info)
5. [Type Formatters](#type-formatters)
6. [Optimization Considerations](#optimization-considerations)

---

## Overview

The **aria-dap** (Debug Adapter Protocol implementation) relies on **DWARF debug information** generated by the compiler to provide debugging features:

| Debug Feature | Required Compiler Output | Benefit |
|---------------|-------------------------|---------|
| **Breakpoints** | Line number tables | Map source lines to machine addresses |
| **Variable Inspection** | Variable debug info | Show variable names, types, locations |
| **Stack Traces** | Call frame info | Unwind stack, show function names |
| **Type Inspection** | Type debug info | Display structured data (Result<T>, TBB) |
| **Expression Evaluation** | Symbol table | Evaluate expressions in current scope |

**Key Dependency**: Compiler must emit complete DWARF debug information

---

## DWARF Debug Information

### What is DWARF?

**DWARF**: Debugging With Attributed Record Formats

**Purpose**: Standard format for debug information in executable files

**Used By**: GDB, LLDB, Visual Studio Code (via DAP)

---

### Compiler Generation

**Flag**: `--debug-symbols` (or `-g` internally)

**Example**:
```bash
$ ariac main.aria --debug-symbols -o my_app
```

**Compiler Invokes**:
```bash
# Internally calls LLVM with debug info enabled
clang++ -g -c main.ll -o main.o
```

**Result**: Object file contains `.debug_info`, `.debug_line`, `.debug_str` sections

---

### DWARF Sections

**ELF Executable** (Linux):
```
$ readelf -S my_app

Section Headers:
  [Nr] Name              Type      Size
  [26] .debug_info       PROGBITS  12345
  [27] .debug_abbrev     PROGBITS  2345
  [28] .debug_line       PROGBITS  3456
  [29] .debug_str        PROGBITS  4567
  [30] .debug_loc        PROGBITS  1234
  [31] .debug_ranges     PROGBITS  789
```

**Sections**:
- `.debug_info`: Type information, variable names, scopes
- `.debug_line`: Source line number mappings
- `.debug_str`: String table (variable names, file paths)
- `.debug_loc`: Variable locations (registers, stack offsets)
- `.debug_ranges`: Address ranges for scopes

---

## Source Line Mapping

### Line Number Tables

**Purpose**: Map machine code addresses to source line numbers

**Example Aria Code**:
```aria
func:main = i64() {
    io.stdout.write("Hello\n");  // Line 2
    var:x = i32(42);             // Line 3
    pass(0);                     // Line 4
}
```

**Compiled Assembly** (with line annotations):
```asm
main:
    push    rbp
    mov     rbp, rsp
    ; Line 2: io.stdout.write("Hello\n")
    lea     rdi, [.str]
    mov     rsi, 6
    call    aria_stdout_write
    ; Line 3: var:x = i32(42)
    mov     DWORD PTR [rbp-4], 42
    ; Line 4: pass(0)
    xor     eax, eax
    pop     rbp
    ret
```

---

**Line Number Table** (DWARF `.debug_line`):
```
Address      Line  File
0x401000     1     main.aria
0x401005     2     main.aria
0x401020     3     main.aria
0x401030     4     main.aria
```

**DAP Usage**: When user sets breakpoint at line 3, DAP looks up address `0x401020` in table

---

### Compiler Implementation

**LLVM IR Generation** (with debug metadata):
```cpp
// src/backend/ir_generator.cpp
void IRGenerator::generate_function(FuncDeclNode* func) {
    // Create debug info for function
    llvm::DISubprogram* debug_func = di_builder->createFunction(
        di_file,  // Source file
        func->name,  // Function name
        func->name,  // Linkage name
        di_file,  // File
        func->location.line,  // Line number
        di_func_type,  // Type
        func->location.line,  // Scope line
        llvm::DINode::FlagPrototyped,
        llvm::DISubprogram::SPFlagDefinition
    );
    
    llvm_func->setSubprogram(debug_func);
    
    // Generate body with line info
    for (ASTNode* stmt : func->body->statements) {
        // Set debug location for each statement
        llvm::DILocation* loc = llvm::DILocation::get(
            context,
            stmt->location.line,
            stmt->location.col,
            debug_func
        );
        builder.SetCurrentDebugLocation(loc);
        
        // Generate IR for statement
        generate_statement(stmt);
    }
}
```

**Result**: Every LLVM instruction has associated debug location

---

## Variable Debug Info

### Local Variables

**Aria Code**:
```aria
func:main = i64() {
    var:x = i32(42);
    var:y = i32(10);
    var:z = i32(x + y);
    pass(0);
}
```

**DWARF Debug Info**:
```
DW_TAG_subprogram (main)
  DW_AT_name: "main"
  DW_AT_type: i64
  
  DW_TAG_variable (x)
    DW_AT_name: "x"
    DW_AT_type: i32
    DW_AT_location: DW_OP_fbreg -4  (rbp-4)
  
  DW_TAG_variable (y)
    DW_AT_name: "y"
    DW_AT_type: i32
    DW_AT_location: DW_OP_fbreg -8  (rbp-8)
  
  DW_TAG_variable (z)
    DW_AT_name: "z"
    DW_AT_type: i32
    DW_AT_location: DW_OP_fbreg -12  (rbp-12)
```

**DAP Usage**: When user inspects variables, DAP reads locations from DWARF

---

### Variable Locations

**Stack Variables**:
```
DW_AT_location: DW_OP_fbreg -4  // Stack offset from frame base (rbp)
```

**Register Variables** (optimized):
```
DW_AT_location: DW_OP_reg0  // Stored in register rax
```

**Complex Locations** (optimized, multi-register):
```
DW_AT_location: DW_OP_piece 4, DW_OP_reg1, DW_OP_piece 4, DW_OP_reg2
// 4 bytes in rdx, 4 bytes in rcx
```

---

### Compiler Implementation

**LLVM IR with Debug Info**:
```cpp
void IRGenerator::generate_var_decl(VarDeclNode* var) {
    // Allocate stack space
    llvm::AllocaInst* alloca = builder.CreateAlloca(
        get_llvm_type(var->type),
        nullptr,
        var->name
    );
    
    // Create debug info for variable
    llvm::DILocalVariable* debug_var = di_builder->createAutoVariable(
        current_scope,  // Scope
        var->name,  // Name
        di_file,  // File
        var->location.line,  // Line
        get_di_type(var->type)  // Type
    );
    
    // Insert debug declare
    di_builder->insertDeclare(
        alloca,  // Variable storage
        debug_var,  // Debug info
        di_builder->createExpression(),  // Location expression
        llvm::DILocation::get(context, var->location.line, var->location.col, current_scope),
        builder.GetInsertBlock()
    );
    
    // Store initial value
    builder.CreateStore(initial_value, alloca);
}
```

---

## Type Debug Info

### Primitive Types

**DWARF**:
```
DW_TAG_base_type
  DW_AT_name: "i32"
  DW_AT_encoding: DW_ATE_signed
  DW_AT_byte_size: 4
```

**Compiler**:
```cpp
llvm::DIBasicType* get_di_type_i32() {
    return di_builder->createBasicType(
        "i32",  // Name
        32,  // Size in bits
        llvm::dwarf::DW_ATE_signed  // Encoding
    );
}
```

---

### Struct Types

**Aria Code**:
```aria
struct:point = { x: i32, y: i32 };
```

**DWARF**:
```
DW_TAG_structure_type
  DW_AT_name: "point"
  DW_AT_byte_size: 8
  
  DW_TAG_member (x)
    DW_AT_name: "x"
    DW_AT_type: <i32>
    DW_AT_data_member_location: 0
  
  DW_TAG_member (y)
    DW_AT_name: "y"
    DW_AT_type: <i32>
    DW_AT_data_member_location: 4
```

**Compiler**:
```cpp
llvm::DICompositeType* get_di_type_struct(StructType* type) {
    std::vector<llvm::Metadata*> elements;
    
    for (size_t i = 0; i < type->fields.size(); i++) {
        Field* field = type->fields[i];
        
        llvm::DIDerivedType* member = di_builder->createMemberType(
            di_scope,  // Scope
            field->name,  // Name
            di_file,  // File
            0,  // Line
            field->type->size * 8,  // Size in bits
            0,  // Alignment
            field->offset * 8,  // Offset in bits
            llvm::DINode::FlagZero,  // Flags
            get_di_type(field->type)  // Type
        );
        
        elements.push_back(member);
    }
    
    return di_builder->createStructType(
        di_scope,
        type->name,
        di_file,
        0,  // Line
        type->size * 8,  // Size in bits
        0,  // Alignment
        llvm::DINode::FlagZero,
        nullptr,  // Derived from
        di_builder->getOrCreateArray(elements)  // Members
    );
}
```

---

### Result<T> Type

**Aria Code**:
```aria
result<i32>:r = divide(10, 2);
```

**DWARF** (tagged union):
```
DW_TAG_structure_type
  DW_AT_name: "result<i32>"
  DW_AT_byte_size: 16
  
  DW_TAG_member (is_ok)
    DW_AT_name: "is_ok"
    DW_AT_type: <bool>
    DW_AT_data_member_location: 0
  
  DW_TAG_member (data)
    DW_AT_name: "data"
    DW_AT_type: <union>
    DW_AT_data_member_location: 4
    
    DW_TAG_union_type
      DW_TAG_member (ok_value)
        DW_AT_name: "ok_value"
        DW_AT_type: <i32>
      
      DW_TAG_member (err_value)
        DW_AT_name: "err_value"
        DW_AT_type: <aria_string>
```

---

## Type Formatters

### Purpose

**Problem**: Raw memory display is unhelpful

**Example** (raw bytes):
```
r (result<i32>):
  is_ok: 0x01
  data: 0x00 0x00 0x00 0x05 0x00 0x00 0x00 0x00
```

**User Wants**:
```
r (result<i32>): Ok(5)
```

---

### LLDB Python Formatters

**DAP Uses**: LLDB with custom Python formatters

**Implementation**: `/home/randy/._____RANDY_____/REPOS/aria-dap/formatters/aria_formatters.py`

---

**Result<T> Formatter**:
```python
import lldb

def result_summary(value, internal_dict):
    """Format Result<T> as Ok(value) or Err(message)"""
    # Read is_ok field
    is_ok = value.GetChildMemberWithName('is_ok').GetValueAsUnsigned()
    
    if is_ok:
        # Ok variant
        ok_value = value.GetChildMemberWithName('data').GetChildMemberWithName('ok_value')
        return f"Ok({ok_value.GetValue()})"
    else:
        # Err variant
        err_msg = value.GetChildMemberWithName('data').GetChildMemberWithName('err_value').GetChildMemberWithName('msg')
        err_len = value.GetChildMemberWithName('data').GetChildMemberWithName('err_value').GetChildMemberWithName('len').GetValueAsUnsigned()
        
        # Read error string
        error = lldb.SBError()
        msg_str = value.GetProcess().ReadMemory(err_msg.GetValueAsUnsigned(), err_len, error)
        if error.Success():
            return f"Err(\"{msg_str.decode('utf-8')}\")"
        else:
            return "Err(<invalid>)"

def __lldb_init_module(debugger, internal_dict):
    # Register formatter
    debugger.HandleCommand('type summary add -F aria_formatters.result_summary "result_i32"')
    debugger.HandleCommand('type summary add -F aria_formatters.result_summary "result_i64"')
    # ... for all instantiated Result<T> types
```

---

**TBB Formatter**:
```python
def tbb_summary(value, internal_dict):
    """Format TBB as value or ERR"""
    base_type = value.GetType().GetName()  # e.g., "tbb_i32"
    
    val = value.GetValueAsSigned()
    
    # Check for ERR sentinel
    if base_type == "tbb_i32" and val == -2147483648:
        return "ERR"
    elif base_type == "tbb_i64" and val == -9223372036854775808:
        return "ERR"
    else:
        return str(val)

def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand('type summary add -F aria_formatters.tbb_summary "tbb_i32"')
    debugger.HandleCommand('type summary add -F aria_formatters.tbb_summary "tbb_i64"')
```

---

**6-Stream Handle Formatter**:
```python
def stream_summary(value, internal_dict):
    """Format stream handles with names"""
    fd = value.GetChildMemberWithName('fd').GetValueAsUnsigned()
    
    stream_names = {
        0: "stdin",
        1: "stdout",
        2: "stderr",
        3: "stddbg",
        4: "stddati",
        5: "stddato"
    }
    
    if fd in stream_names:
        return f"{stream_names[fd]} (FD {fd})"
    else:
        return f"FD {fd}"

def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand('type summary add -F aria_formatters.stream_summary "input_stream"')
    debugger.HandleCommand('type summary add -F aria_formatters.stream_summary "output_stream"')
```

---

### DAP Integration

**Loading Formatters**:
```cpp
// aria-dap main.cpp
void DebugSession::start() {
    // Create LLDB debugger
    lldb::SBDebugger debugger = lldb::SBDebugger::Create();
    
    // Load Aria formatters
    lldb::SBError error;
    debugger.GetCommandInterpreter().HandleCommand(
        "command script import /usr/local/lib/aria/formatters/aria_formatters.py",
        &error
    );
    
    if (error.Fail()) {
        std::cerr << "Failed to load formatters: " << error.GetCString() << std::endl;
    }
    
    // Continue debugging...
}
```

---

## Optimization Considerations

### Debug vs Release Builds

**Debug Build** (`-O0`):
- All variables in memory (stack/heap)
- No inlining
- Predictable control flow
- **Easy to debug**

**Release Build** (`-O2`, `-O3`):
- Variables in registers (no memory location)
- Inlining (functions disappear)
- Reordered instructions
- **Hard to debug**

---

### Debugging Optimized Code

**Problem**: Variable optimized away

```aria
func:compute = i32(x: i32) {
    var:temp = i32(x * 2);  // Inlined, no stack allocation
    pass(temp + 5);
}
```

**Optimized Assembly**:
```asm
compute:
    lea  eax, [rdi*2 + 5]  // temp doesn't exist!
    ret
```

**DWARF** (with optimization):
```
DW_TAG_variable (temp)
  DW_AT_name: "temp"
  DW_AT_location: <optimized out>
```

**Debugger Shows**: `temp: <optimized out>`

---

### Balancing Performance and Debuggability

**Strategy**: Compile with `-Og` (optimize for debugging)

**Characteristics**:
- Minimal optimization (faster than `-O0`, slower than `-O2`)
- Preserves variable locations
- Enables some inlining (but tracks it in debug info)

**Recommendation**: Use `-Og` for development builds, `-O2` for production

---

## Related Documents

- **[ARIA_DAP](../components/ARIA_DAP.md)**: Debug adapter architecture
- **[ARIA_COMPILER](../components/ARIA_COMPILER.md)**: Compiler backend (DWARF generation)
- **[TYPE_SYSTEM](../specs/TYPE_SYSTEM.md)**: Type definitions (for formatters)
- **[ERROR_HANDLING](../specs/ERROR_HANDLING.md)**: Result<T> and TBB (debugging implications)
- **[COMPILER_RUNTIME](./COMPILER_RUNTIME.md)**: Compiler ↔ Runtime integration

---

**Document Version**: 1.0  
**Author**: Aria Ecosystem Documentation  
**Status**: Reference guide (implementation planned, DWARF generation in compiler confirmed)
