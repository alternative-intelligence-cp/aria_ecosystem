# The `int128` Type

**Category**: Types → Integers  
**Syntax**: `int128` (alias: `i128`)  
**Purpose**: 128-bit signed integer for very large values

---

## Overview

`int128` is a **128-bit signed integer** using two's complement representation. Use for cryptography, high-precision calculations, or very large numbers.

**Alias**: `i128`

---

## Range

| Aspect | Value |
|--------|-------|
| **Minimum** | `-170,141,183,460,469,231,731,687,303,715,884,105,728` |
| **Maximum** | `+170,141,183,460,469,231,731,687,303,715,884,105,727` |
| **Total Values** | ~340 undecillion |
| **Storage** | 128 bits (16 bytes) |

---

## Declaration

```aria
// Explicit type
big: int128 = 123456789012345678901234567890;

// Using alias
huge: i128 = 99999999999999999999i128;

// Type suffix required for large literals
x := 9999999999999999999i128;
```

---

## Operations

### Arithmetic

```aria
a: i128 = 10000000000000000000;
b: i128 = 20000000000000000000;

sum: i128 = a + b;
prod: i128 = a * b;
```

### Performance Note

```aria
// i128 operations are slower than i64
// Use only when necessary

fast: i64 = 1000;       // Fast
slow: i128 = 1000i128;  // Slower
```

---

## Use Cases

### Cryptography

```aria
// Large prime numbers
prime: i128 = 340282366920938463463374607431768211297i128;

// Cryptographic keys
key: i128 = generate_large_prime();
```

### High-Precision Calculations

```aria
// Financial calculations with extreme precision
// (in 1/1000th of a cent)
balance: i128 = 123456789012345678i128;
```

### UUID/GUID Storage

```aria
// Store 128-bit UUIDs as integers
uuid: i128 = parse_uuid("550e8400-e29b-41d4-a716-446655440000");
```

---

## Best Practices

### ✅ DO: Use for Cryptography

```aria
// Perfect for large primes
modulus: i128 = large_prime();
```

### ✅ DO: Use Type Suffix

```aria
// Required for large literals
x: i128 = 99999999999999999999i128;
```

### ❌ DON'T: Use for Ordinary Values

```aria
// Wasteful and slow
counter: i128 = 0i128;  // ❌ Use i32
id: i128 = 42i128;      // ❌ Use i64
```

### ❌ DON'T: Assume Fast Performance

```aria
// i128 arithmetic is slower
for i: i128 in 0..1000000i128 {  // ❌ Slow!
    process(i);
}

// Better
for i: i32 in 0..1000000 {  // ✅ Fast
    process(i as i128);
}
```

---

## Conversions

### From Smaller Types

```aria
small: i64 = 1000000000000;
big: i128 = small as i128;  // Safe
```

### To Smaller Types (Dangerous)

```aria
huge: i128 = 99999999999999999999i128;
small: i64 = huge as i64;  // Truncates!
```

### Checked Conversion

```aria
fn to_i64(value: i128) -> Result<i64> {
    min: i128 = -9223372036854775808i128;
    max: i128 = 9223372036854775807i128;
    
    when value < min or value > max then
        return Err("Value out of range");
    end
    
    return Ok(value as i64);
}
```

---

## Common Patterns

### UUID Handling

```aria
// Convert UUID to/from i128
fn uuid_to_int(uuid: string) -> i128 {
    // Parse hex string
    return parse_hex_i128(uuid.remove("-"));
}

fn int_to_uuid(value: i128) -> string {
    hex: string = to_hex(value);
    // Format as UUID
    return format_uuid(hex);
}
```

### Large Factorial

```aria
// Factorial up to ~33
fn factorial(n: i32) -> i128 {
    result: i128 = 1i128;
    for i: i32 in 2..=n {
        result *= i as i128;
    }
    return result;
}
```

---

## Platform Support

```aria
// Not all CPUs have native i128 support
// May use software emulation (slower)

// Check if hardware-supported
has_i128: bool = is_i128_native();
```

---

## Literal Syntax

```aria
// Decimal with suffix
x: i128 = 123456789012345678901234567890i128;

// Hexadecimal
hex: i128 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi128;

// Binary (very long!)
bin: i128 = 0b1111_1111_..._1111i128;

// Underscores for readability
readable: i128 = 340_282_366_920_938_463_463i128;
```

---

## Related

- [int64](int64.md) - 64-bit integer
- [int256](int256.md) - 256-bit integer
- [uint128](uint128.md) - Unsigned 128-bit
- [tbb128](tbb128.md) - 128-bit with ERR sentinel (if exists)

---

**Remember**: `i128` is **slow** - use only when **necessary**!
