# The `int256` Type

**Category**: Types → Integers  
**Syntax**: `int256` (alias: `i256`)  
**Purpose**: 256-bit signed integer for cryptographic and extreme precision needs

---

## Overview

`int256` is a **256-bit signed integer** using two's complement representation. Primarily used in cryptography and blockchain applications.

**Alias**: `i256`

---

## Range

| Aspect | Value |
|--------|-------|
| **Minimum** | Approximately -5.8 × 10^76 |
| **Maximum** | Approximately +5.8 × 10^76 |
| **Total Values** | ~1.16 × 10^77 |
| **Storage** | 256 bits (32 bytes) |

---

## Declaration

```aria
// Explicit type with suffix
big: int256 = 12345678901234567890123456789012345678901234567890i256;

// Using alias
value: i256 = 999i256;

// Type suffix required
x := 1234567890123456789012345678i256;
```

---

## Operations

### Arithmetic

```aria
a: i256 = 10000000000000000000000000000i256;
b: i256 = 20000000000000000000000000000i256;

sum: i256 = a + b;
prod: i256 = a * b;  // Very slow!
```

### Performance Warning

```aria
// ⚠️ i256 operations are VERY slow
// Always use software emulation
// No hardware support on any current CPU
```

---

## Use Cases

### Blockchain/Cryptocurrency

```aria
// Ethereum-style 256-bit integers
balance: i256 = 1000000000000000000i256;  // 1 ETH in wei

// Smart contract calculations
total_supply: i256 = 21000000000000000000000000i256;
```

### Cryptographic Operations

```aria
// Large prime modulus
modulus: i256 = generate_256bit_prime();

// RSA-style calculations
encrypted: i256 = power_mod(message, exponent, modulus);
```

### High-Precision Scientific Computing

```aria
// Extreme precision calculations
planck_time: i256 = 5391247i256;  // In 10^-44 seconds
```

---

## Best Practices

### ✅ DO: Use for Blockchain

```aria
// Perfect for Ethereum-style apps
wei_amount: i256 = 1000000000000000000i256;
gas_price: i256 = 20000000000i256;
```

### ✅ DO: Use for Large Cryptography

```aria
// 256-bit cryptographic operations
key: i256 = generate_key_256();
signature: i256 = sign_message(key, msg);
```

### ❌ DON'T: Use for Normal Code

```aria
// Extremely wasteful and slow
counter: i256 = 0i256;  // ❌ Use i32
id: i256 = 42i256;      // ❌ Use i64
```

### ❌ DON'T: Expect Performance

```aria
// VERY slow - software emulation only
for i: i256 in 0..1000000i256 {  // ❌ Terrible!
    heavy_calc(i);
}
```

---

## Conversions

### From Smaller Types

```aria
normal: i64 = 1234567890;
huge: i256 = normal as i256;  // Safe but slow
```

### To Smaller Types (Very Dangerous)

```aria
huge: i256 = 12345678901234567890123456789i256;
tiny: i64 = huge as i64;  // Massive truncation!
```

---

## Common Patterns

### Ethereum Wei Conversion

```aria
// Convert ETH to wei
fn eth_to_wei(eth: flt64) -> i256 {
    wei_per_eth: i256 = 1000000000000000000i256;
    return (eth as i256) * wei_per_eth;
}

// Convert wei to ETH
fn wei_to_eth(wei: i256) -> flt64 {
    wei_per_eth: i256 = 1000000000000000000i256;
    return (wei as flt64) / (wei_per_eth as flt64);
}
```

### Modular Arithmetic

```aria
// Cryptographic modular exponentiation
fn mod_pow(base: i256, exp: i256, modulus: i256) -> i256 {
    result: i256 = 1i256;
    base = base % modulus;
    
    while exp > 0i256 {
        when (exp % 2i256) == 1i256 then
            result = (result * base) % modulus;
        end
        exp = exp >> 1;
        base = (base * base) % modulus;
    }
    
    return result;
}
```

---

## Blockchain Integration

```aria
// Smart contract balance tracking
struct Account {
    address: string,
    balance: i256,
    nonce: i64
}

fn transfer(from: &Account, to: &Account, amount: i256) -> Result<void> {
    when from.balance < amount then
        return Err("Insufficient balance");
    end
    
    from.balance -= amount;
    to.balance += amount;
    
    return Ok();
}
```

---

## Literal Syntax

```aria
// Decimal with suffix (required for large values)
x: i256 = 123456789012345678901234567890i256;

// Hexadecimal
max: i256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi256;

// Underscores for readability
readable: i256 = 1_000_000_000_000_000_000_000_000i256;
```

---

## Related

- [int128](int128.md) - 128-bit integer
- [int512](int512.md) - 512-bit integer
- [uint256](uint256.md) - Unsigned 256-bit
- [flt256](flt256.md) - 256-bit floating point

---

**Remember**: `i256` is **extremely slow** - use **only** for blockchain/crypto!
